"use strict";(self.webpackChunkbiofile_finder=self.webpackChunkbiofile_finder||[]).push([[839],{8839:(t,e,r)=>{r.r(e),r.d(e,{Array:()=>W,BoolArray:()=>a,ByteStringArray:()=>i,FetchStore:()=>bt,Group:()=>j,IndexError:()=>Q,KeyError:()=>s,Location:()=>$,NodeNotFoundError:()=>n,UnicodeStringArray:()=>o,_zarrita_internal_get:()=>rt,_zarrita_internal_get_strides:()=>l,_zarrita_internal_set:()=>st,_zarrita_internal_slice_indices:()=>K,create:()=>V,get:()=>ut,open:()=>G,registry:()=>L,root:()=>B,set:()=>dt,slice:()=>H,tryWithConsolidated:()=>pt,withConsolidated:()=>yt});class n extends Error{constructor(t,e={}){super(`Node not found: ${t}`,e),this.name="NodeNotFoundError"}}class s extends Error{constructor(t){super(`Missing key: ${t}`),this.name="KeyError"}}class a{#t;constructor(t,e,r){"number"==typeof t?this.#t=new Uint8Array(t):t instanceof ArrayBuffer?this.#t=new Uint8Array(t,e,r):this.#t=new Uint8Array(Array.from(t,(t=>t?1:0)))}get BYTES_PER_ELEMENT(){return 1}get byteOffset(){return this.#t.byteOffset}get byteLength(){return this.#t.byteLength}get buffer(){return this.#t.buffer}get length(){return this.#t.length}get(t){let e=this.#t[t];return"number"==typeof e?0!==e:e}set(t,e){this.#t[t]=e?1:0}fill(t){this.#t.fill(t?1:0)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}class i{_data;chars;#e;constructor(t,e,r,n){if(this.chars=t,this.#e=new TextEncoder,"number"==typeof e)this._data=new Uint8Array(e*t);else if(e instanceof ArrayBuffer)n&&(n*=t),this._data=new Uint8Array(e,r,n);else{let r=Array.from(e);this._data=new Uint8Array(r.length*t);for(let t=0;t<r.length;t++)this.set(t,r[t])}}get BYTES_PER_ELEMENT(){return this.chars}get byteOffset(){return this._data.byteOffset}get byteLength(){return this._data.byteLength}get buffer(){return this._data.buffer}get length(){return this.byteLength/this.BYTES_PER_ELEMENT}get(t){const e=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);return(new TextDecoder).decode(e).replace(/\x00/g,"")}set(t,e){const r=new Uint8Array(this.buffer,this.byteOffset+this.chars*t,this.chars);r.fill(0),r.set(this.#e.encode(e))}fill(t){const e=this.#e.encode(t);for(let t=0;t<this.length;t++)this._data.set(e,t*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}class o{#r;chars;constructor(t,e,r,n){if(this.chars=t,"number"==typeof e)this.#r=new Int32Array(e*t);else if(e instanceof ArrayBuffer)n&&(n*=t),this.#r=new Int32Array(e,r,n);else{const r=e,n=new o(t,1);this.#r=new Int32Array(function*(){for(let t of r)n.set(0,t),yield*n.#r}())}}get BYTES_PER_ELEMENT(){return this.#r.BYTES_PER_ELEMENT*this.chars}get byteLength(){return this.#r.byteLength}get byteOffset(){return this.#r.byteOffset}get buffer(){return this.#r.buffer}get length(){return this.#r.length/this.chars}get(t){const e=this.chars*t;let r="";for(let t=0;t<this.chars;t++)r+=String.fromCodePoint(this.#r[e+t]);return r.replace(/\u0000/g,"")}set(t,e){const r=this.chars*t,n=this.#r.subarray(r,r+this.chars);n.fill(0);for(let t=0;t<this.chars;t++)n[t]=e.codePointAt(t)??0}fill(t){this.set(0,t);let e=this.#r.subarray(0,this.chars);for(let t=1;t<this.length;t++)this.#r.set(e,t*this.chars)}*[Symbol.iterator](){for(let t=0;t<this.length;t++)yield this.get(t)}}function c(t){const e=JSON.stringify(t,null,2);return(new TextEncoder).encode(e)}function u(t){const e=(new TextDecoder).decode(t);return JSON.parse(e)}function d(t,e){const r=e/2,n=e-1;let s=0;for(let a=0;a<t.length;a+=e)for(let e=0;e<r;e+=1)s=t[a+e],t[a+e]=t[a+n-e],t[a+n-e]=s}function h(t){if("v2:object"===t)return globalThis.Array;let e=t.match(/v2:([US])(\d+)/);if(e){let[,t,r]=e;return("U"===t?o:i).bind(null,Number(r))}let r={int8:Int8Array,int16:Int16Array,int32:Int32Array,int64:globalThis.BigInt64Array,uint8:Uint8Array,uint16:Uint16Array,uint32:Uint32Array,uint64:globalThis.BigUint64Array,float16:globalThis.Float16Array,float32:Float32Array,float64:Float64Array,bool:a}[t];return g(r,`Unknown or unsupported data_type: ${t}`),r}function l(t,e){const r=t.length;"string"==typeof e&&(e="C"===e?Array.from({length:r},((t,e)=>e)):Array.from({length:r},((t,e)=>r-1-e))),g(r===e.length,"Order length must match the number of dimensions.");let n=1,s=new Array(r);for(let r=e.length-1;r>=0;r--)s[e[r]]=n,n*=t[e[r]];return s}function f({name:t,configuration:e}){if("default"===t){const t=e?.separator??"/";return e=>["c",...e].join(t)}if("v2"===t){const t=e?.separator??".";return e=>e.join(t)||"0"}throw new Error(`Unknown chunk key encoding: ${t}`)}function y(t){return"sharding_indexed"===t?.name}function p(t){return"uint64"!==t.data_type&&"int64"!==t.data_type||null==t.fill_value?t.fill_value:BigInt(t.fill_value)}function _(t,...e){if(!e.some((e=>t instanceof e)))throw t}function g(t,e=""){if(!t)throw new Error(e)}async function m(t,{format:e,signal:r}){const n=t instanceof Response?t:new Response(t);g(n.body,"Response does not contain body.");try{const t=new Response(n.body.pipeThrough(new DecompressionStream(e),{signal:r}));return await t.arrayBuffer()}catch{throw r?.throwIfAborted(),new Error(`Failed to decode ${e}`)}}class b{kind="array_to_array";constructor(t,e){g(t.keepbits>=0,"keepbits must be zero or positive")}static fromConfig(t,e){return new b(t,e)}encode(t){throw new Error("`BitroundCodec.encode` is not implemented. Please open an issue at https://github.com/manzt/zarrita.js/issues.")}decode(t){return t}}const w=function(){const t=new Uint32Array([305419896]);return!(18===new Uint8Array(t.buffer,t.byteOffset,t.byteLength)[0])}();function k(t){return"BYTES_PER_ELEMENT"in t?t.BYTES_PER_ELEMENT:4}class E{kind="array_to_bytes";#n;#s;#a;#i;#o;constructor(t,e){this.#o=t?.endian,this.#s=h(e.data_type),this.#i=e.shape,this.#n=l(e.shape,"C");const r=new this.#s(0);this.#a=r.BYTES_PER_ELEMENT}static fromConfig(t,e){return new E(t,e)}encode(t){let e=new Uint8Array(t.data.buffer);return w&&"big"===this.#o&&d(e,k(this.#s)),e}decode(t){return w&&"big"===this.#o&&d(t,k(this.#s)),{data:new this.#s(t.buffer,t.byteOffset,t.byteLength/this.#a),shape:this.#i,stride:this.#n}}}class v{kind="bytes_to_bytes";static fromConfig(){return new v}encode(t){throw new Error("Not implemented")}decode(t){return new Uint8Array(t.buffer,t.byteOffset,t.byteLength-4)}}class A{kind="bytes_to_bytes";static fromConfig(t){return new A}encode(t){throw new Error("Gzip encoding is not enabled by default. Please register a custom codec with `numcodecs/gzip`.")}async decode(t){const e=await m(t,{format:"gzip"});return new Uint8Array(e)}}function T(t,e){return g(!Number.isNaN(e),"JsonCodec allow_nan is false but NaN was encountered during encoding."),g(e!==Number.POSITIVE_INFINITY,"JsonCodec allow_nan is false but Infinity was encountered during encoding."),g(e!==Number.NEGATIVE_INFINITY,"JsonCodec allow_nan is false but -Infinity was encountered during encoding."),e}function x(t,e){return e instanceof Object&&!Array.isArray(e)?Object.keys(e).sort().reduce(((t,r)=>(t[r]=e[r],t)),{}):e}class N{configuration;kind="array_to_bytes";#c;#u;constructor(t={}){this.configuration=t;const{encoding:e="utf-8",skipkeys:r=!1,ensure_ascii:n=!0,check_circular:s=!0,allow_nan:a=!0,sort_keys:i=!0,indent:o,strict:c=!0}=t;let u=t.separators;u||(u=o?[", ",": "]:[",",":"]),this.#c={encoding:e,skipkeys:r,ensure_ascii:n,check_circular:s,allow_nan:a,indent:o,separators:u,sort_keys:i},this.#u={strict:c}}static fromConfig(t){return new N(t)}encode(t){const{indent:e,encoding:r,ensure_ascii:n,check_circular:s,allow_nan:a,sort_keys:i}=this.#c;g("utf-8"===r,"JsonCodec does not yet support non-utf-8 encoding.");const o=[];g(s,"JsonCodec does not yet support skipping the check for circular references during encoding."),a||o.push(T),i&&o.push(x);const c=Array.from(t.data);let u;c.push("|O"),c.push(t.shape),o.length&&(u=(t,e)=>{let r=e;for(let e of o)r=e(t,r);return r});let d=JSON.stringify(c,u,e);return n&&(d=d.replace(/[\u007F-\uFFFF]/g,(t=>{const e=`0000${t.charCodeAt(0).toString(16)}`;return`\\u${e.substring(e.length-4)}`}))),(new TextEncoder).encode(d)}decode(t){const{strict:e}=this.#u;g(e,"JsonCodec does not yet support non-strict decoding.");const r=u(t),n=r.pop();return r.pop(),g(n,"0D not implemented for JsonCodec."),{data:r,shape:n,stride:l(n,"C")}}}function S(t){return t instanceof a||t instanceof i||t instanceof o?new Proxy(t,{get:(t,e)=>t.get(Number(e)),set:(t,e,r)=>(t.set(Number(e),r),!0)}):t}class z{kind="array_to_array";#d;#h;constructor(t,e){let r=t.order??"C",n=e.shape.length,s=new Array(n),a=new Array(n);if("C"===r)for(let t=0;t<n;++t)s[t]=t,a[t]=t;else if("F"===r)for(let t=0;t<n;++t)s[t]=n-t-1,a[t]=n-t-1;else s=r,s.forEach(((t,e)=>{g(void 0===a[t],`Invalid permutation: ${JSON.stringify(r)}`),a[t]=e}));this.#d=s,this.#h=a}static fromConfig(t,e){return new z(t,e)}encode(t){return function(t,e){let r=function(t){return g(t.shape.length===t.stride.length,"Shape and stride must have the same length."),t.stride.map(((t,e)=>({stride:t,index:e}))).sort(((t,e)=>e.stride-t.stride)).map((t=>t.index))}(t);return g(r.length===e.length,"Orders must match"),r.every(((t,r)=>t===e[r]))}(t,this.#h)?t:function(t,e){let r=function(t,e){let r;return r=t.data instanceof i||t.data instanceof o?new t.constructor(t.data.length,t.data.chars):new t.constructor(t.data.length),{data:r,shape:t.shape,stride:l(t.shape,e)}}(t,e),n=t.shape.length,s=t.data.length,a=Array(n).fill(0),c=S(t.data),u=S(r.data);for(let e=0;e<s;e++){let s=0;for(let t=0;t<n;t++)s+=a[t]*r.stride[t];u[s]=c[e],a[0]+=1;for(let e=0;e<n;e++)if(a[e]===t.shape[e]){if(e+1===n)break;a[e]=0,a[e+1]+=1}}return r}(t,this.#h)}decode(t){return{data:t.data,shape:t.shape,stride:l(t.shape,this.#d)}}}class C{kind="array_to_bytes";#i;#l;constructor(t){this.#i=t,this.#l=l(t,"C")}static fromConfig(t,e){return new C(e.shape)}encode(t){throw new Error("Method not implemented.")}decode(t){let e=new TextDecoder,r=new DataView(t.buffer),n=Array(r.getUint32(0,!0)),s=4;for(let a=0;a<n.length;a++){let i=r.getUint32(s,!0);s+=4,n[a]=e.decode(t.buffer.slice(s,s+i)),s+=i}return{data:n,shape:this.#i,stride:this.#l}}}class U{kind="bytes_to_bytes";static fromConfig(t){return new U}encode(t){throw new Error("Zlib encoding is not enabled by default. Please register a codec with `numcodecs/zlib`.")}async decode(t){const e=await m(t,{format:"deflate"});return new Uint8Array(e)}}const L=(new Map).set("blosc",(()=>r.e(634).then(r.bind(r,7634)).then((t=>t.default)))).set("lz4",(()=>r.e(829).then(r.bind(r,8829)).then((t=>t.default)))).set("zstd",(()=>r.e(580).then(r.bind(r,9580)).then((t=>t.default)))).set("gzip",(()=>A)).set("zlib",(()=>U)).set("transpose",(()=>z)).set("bytes",(()=>E)).set("crc32c",(()=>v)).set("vlen-utf8",(()=>C)).set("json2",(()=>N)).set("bitround",(()=>b));function M(t){let e;return{async encode(r){e||(e=await O(t));for(const t of e.array_to_array)r=await t.encode(r);let n=await e.array_to_bytes.encode(r);for(const t of e.bytes_to_bytes)n=await t.encode(n);return n},async decode(r){e||(e=await O(t));for(let t=e.bytes_to_bytes.length-1;t>=0;t--)r=await e.bytes_to_bytes[t].decode(r);let n=await e.array_to_bytes.decode(r);for(let t=e.array_to_array.length-1;t>=0;t--)n=await e.array_to_array[t].decode(n);return n}}}async function O(t){let e,r=t.codecs.map((async t=>{let e=await(L.get(t.name)?.());return g(e,`Unknown codec: ${t.name}`),{Codec:e,meta:t}})),n=[],s=[];for await(let{Codec:a,meta:i}of r){let r=a.fromConfig(i.configuration,t);switch(r.kind){case"array_to_array":n.push(r);break;case"array_to_bytes":e=r;break;default:s.push(r)}}return e||(g("v2:object"!==t.data_type,`Cannot encode ${t.data_type} to bytes without a codec`),e=E.fromConfig({endian:"little"},t)),{array_to_array:n,array_to_bytes:e,bytes_to_bytes:s}}const I=18446744073709551615n;function R(t,e,r,n){g(t.store.getRange,"Store does not support range requests");let s=t.store.getRange.bind(t.store),a=e.map(((t,e)=>t/n.chunk_shape[e])),i=M({data_type:"uint64",shape:[...a,2],codecs:n.index_codecs}),o={};return async e=>{let n,c=e.map(((t,e)=>Math.floor(t/a[e]))),u=t.resolve(r(c)).path;if(u in o)n=o[u];else{let t=4,e=16*a.reduce(((t,e)=>t*e),1),r=await s(u,{suffixLength:e+t});n=o[u]=r?await i.decode(r):null}if(null===n)return;let{data:d,shape:h,stride:l}=n,f=e.map(((t,e)=>t%h[e])).reduce(((t,e,r)=>t+e*l[r]),0),y=d[f],p=d[f+1];return y!==I||p!==I?s(u,{offset:Number(y),length:Number(p)}):void 0}}class ${store;path;constructor(t,e="/"){this.store=t,this.path=e}resolve(t){let e=new URL(`file://${this.path.endsWith("/")?this.path:`${this.path}/`}`);return new $(this.store,new URL(t,e).pathname)}}function B(t){return new $(t??new Map)}class j extends ${kind="group";#f;constructor(t,e,r){super(t,e),this.#f=r}get attrs(){return this.#f.attributes}}function P(t){const e=t.find((t=>"transpose"===t.name));return e?.configuration?.order??"C"}const F=Symbol("zarrita.context");function Y(t){return t[F]}class W extends ${kind="array";#f;[F];constructor(t,e,r){super(t,e),this.#f={...r,fill_value:p(r)},this[F]=function(t,e){let{configuration:r}=e.codecs.find(y)??{},n={encode_chunk_key:f(e.chunk_key_encoding),TypedArray:h(e.data_type),fill_value:e.fill_value};if(r){let s=P(r.codecs);return{...n,kind:"sharded",chunk_shape:r.chunk_shape,codec:M({data_type:e.data_type,shape:r.chunk_shape,codecs:r.codecs}),get_strides:t=>l(t,s),get_chunk_bytes:R(t,e.chunk_grid.configuration.chunk_shape,n.encode_chunk_key,r)}}let s=P(e.codecs);return{...n,kind:"regular",chunk_shape:e.chunk_grid.configuration.chunk_shape,codec:M({data_type:e.data_type,shape:e.chunk_grid.configuration.chunk_shape,codecs:e.codecs}),get_strides:t=>l(t,s),async get_chunk_bytes(e,r){let s=n.encode_chunk_key(e),a=t.resolve(s).path;return t.store.get(a,r)}}}(this,r)}get attrs(){return this.#f.attributes}get shape(){return this.#f.shape}get chunks(){return this[F].chunk_shape}get dtype(){return this.#f.data_type}async getChunk(t,e){let r=this[F],n=await r.get_chunk_bytes(t,e);if(!n){let t=r.chunk_shape.reduce(((t,e)=>t*e),1),e=new r.TypedArray(t);return e.fill(r.fill_value),{data:e,shape:r.chunk_shape,stride:r.get_strides(r.chunk_shape)}}return r.codec.decode(n)}is(t){return function(t,e){if("number"!==e&&"bigint"!==e&&"boolean"!==e&&"object"!==e&&"string"!==e)return t===e;let r="bool"===t;if("boolean"===e)return r;let n=t.startsWith("v2:U")||t.startsWith("v2:S");if("string"===e)return n;let s="int64"===t||"uint64"===t;if("bigint"===e)return s;let a="v2:object"===t;return"object"===e?a:!(n||s||r||a)}(this.dtype,t)}}let J=function(){let t=new WeakMap;function e(e){let r=t.get(e)??{v2:0,v3:0};return t.set(e,r),r}return{increment(t,r){e(t)[r]+=1},version_max(t){let r=e(t);return r.v3>r.v2?"v3":"v2"}}}();async function q(t,e){let{path:r}=t.resolve(".zarray"),a=await t.store.get(r);if(!a)throw new n("v2 array",{cause:new s(r)});return J.increment(t.store,"v2"),new W(t.store,t.path,function(t,e={}){let r=[],n=function(t){if("|O"===t)return{data_type:"v2:object"};let e=t.match(/^([<|>])(.*)$/);g(e,`Invalid dtype: ${t}`);let[,r,n]=e,s={b1:"bool",i1:"int8",u1:"uint8",i2:"int16",u2:"uint16",i4:"int32",u4:"uint32",i8:"int64",u8:"uint64",f2:"float16",f4:"float32",f8:"float64"}[n]??(n.startsWith("S")||n.startsWith("U")?`v2:${n}`:void 0);return g(s,`Unsupported or unknown dtype: ${t}`),"|"===r?{data_type:s}:{data_type:s,endian:"<"===r?"little":"big"}}(t.dtype);"F"===t.order&&r.push({name:"transpose",configuration:{order:"F"}}),"endian"in n&&"big"===n.endian&&r.push({name:"bytes",configuration:{endian:"big"}});for(let{id:e,...n}of t.filters??[])r.push({name:e,configuration:n});if(t.compressor){let{id:e,...n}=t.compressor;r.push({name:e,configuration:n})}return{zarr_format:3,node_type:"array",shape:t.shape,data_type:n.data_type,chunk_grid:{name:"regular",configuration:{chunk_shape:t.chunks}},chunk_key_encoding:{name:"v2",configuration:{separator:t.dimension_separator??"."}},codecs:r,fill_value:t.fill_value,attributes:e}}(u(a),e))}async function D(t,e){let{path:r}=t.resolve(".zgroup"),a=await t.store.get(r);if(!a)throw new n("v2 group",{cause:new s(r)});return J.increment(t.store,"v2"),new j(t.store,t.path,function(t,e={}){return{zarr_format:3,node_type:"group",attributes:e}}(u(a),e))}async function G(t,e={}){let r="store"in t?t.store:t,s=J.version_max(r),a="v2"===s?G.v2:G.v3,i="v2"===s?G.v3:G.v2;return a(t,e).catch((r=>(_(r,n),i(t,e))))}async function V(t,e={}){let r="store"in t?t:new $(t);if("shape"in e){let t=await async function(t,e){let r={zarr_format:3,node_type:"array",shape:e.shape,data_type:e.data_type,chunk_grid:{name:"regular",configuration:{chunk_shape:e.chunk_shape}},chunk_key_encoding:{name:"default",configuration:{separator:e.chunk_separator??"/"}},codecs:e.codecs??[],fill_value:e.fill_value??null,attributes:e.attributes??{}};return await t.store.set(t.resolve("zarr.json").path,c(r)),new W(t.store,t.path,r)}(r,e);return t}return async function(t,e={}){let r={zarr_format:3,node_type:"group",attributes:e.attributes??{}};return await t.store.set(t.resolve("zarr.json").path,c(r)),new j(t.store,t.path,r)}(r,e)}function K({start:t,stop:e,step:r},n){if(0===r)throw new Error("slice step cannot be zero");const s=(r=r??1)<0,[a,i]=s?[-1,n-1]:[0,n];return null===t?t=s?i:a:t<0?(t+=n)<a&&(t=a):t>i&&(t=i),null===e?e=s?a:i:e<0?(e+=n)<a&&(e=a):e>i&&(e=i),[t,e,r]}function H(t,e,r=null){return void 0===e&&(e=t,t=null),{start:t,stop:e,step:r}}function Z(){const t=[];return{add:e=>t.push(e()),onIdle:()=>Promise.all(t)}}G.v2=async function(t,e={}){let r="store"in t?t:new $(t),s={};return(e.attrs??1)&&(s=await async function(t){let e=await t.store.get(t.resolve(".zattrs").path);return e?u(e):{}}(r)),"array"===e.kind?q(r,s):"group"===e.kind?D(r,s):q(r,s).catch((t=>(_(t,n),D(r,s))))},G.v3=async function(t,e={}){let r="store"in t?t:new $(t),a=await async function(t){let{store:e,path:r}=t.resolve("zarr.json"),a=await t.store.get(r);if(!a)throw new n("v3 array or group",{cause:new s(r)});let i=u(a);return"array"===i.node_type&&(i.fill_value=p(i)),"array"===i.node_type?new W(e,t.path,i):new j(e,t.path,i)}(r);if(J.increment(r.store,"v3"),void 0===e.kind)return a;if("array"===e.kind&&a instanceof W)return a;if("group"===e.kind&&a instanceof j)return a;let i=a instanceof W?"array":"group";throw new Error(`Expected node of kind ${e.kind}, found ${i}.`)};class Q extends Error{constructor(t){super(t),this.name="IndexError"}}class X{dim_sel;dim_len;dim_chunk_len;nitems;constructor({dim_sel:t,dim_len:e,dim_chunk_len:r}){t=function(t,e){return(t=Math.trunc(t))<0&&(t=e+t),(t>=e||t<0)&&function(t){throw new Q(`index out of bounds for dimension with length ${t}`)}(e),t}(t,e),this.dim_sel=t,this.dim_len=e,this.dim_chunk_len=r,this.nitems=1}*[Symbol.iterator](){const t=Math.floor(this.dim_sel/this.dim_chunk_len),e=t*this.dim_chunk_len,r=this.dim_sel-e;yield{dim_chunk_ix:t,dim_chunk_sel:r}}}class tt{start;stop;step;dim_len;dim_chunk_len;nitems;nchunks;constructor({dim_sel:t,dim_len:e,dim_chunk_len:r}){const[n,s,a]=K(t,e);this.start=n,this.stop=s,this.step=a,this.step<1&&function(){throw new Q("only slices with step >= 1 are supported")}(),this.dim_len=e,this.dim_chunk_len=r,this.nitems=Math.max(0,Math.ceil((this.stop-this.start)/this.step)),this.nchunks=Math.ceil(this.dim_len/this.dim_chunk_len)}*[Symbol.iterator](){const t=Math.floor(this.start/this.dim_chunk_len),e=Math.ceil(this.stop/this.dim_chunk_len);for(const r of function*(t,e,r=1){void 0===e&&(e=t,t=0);for(let n=t;n<e;n+=r)yield n}(t,e)){const t=r*this.dim_chunk_len,e=Math.min(this.dim_len,(r+1)*this.dim_chunk_len),n=e-t;let s=0,a=0;if(this.start<t){const e=(t-this.start)%this.step;e&&(a+=this.step-e),s=Math.ceil((t-this.start)/this.step)}else a=this.start-t;const i=this.stop>e?n:this.stop-t,o=[a,i,this.step],c=[s,s+Math.ceil((i-a)/this.step),1];yield{dim_chunk_ix:r,dim_chunk_sel:o,dim_out_sel:c}}}}class et{dim_indexers;shape;constructor({selection:t,shape:e,chunk_shape:r}){this.dim_indexers=function(t,e){let r=[];return null===t?r=e.map((t=>H(null))):Array.isArray(t)&&(r=t.map((t=>t??H(null)))),function(t,e){t.length>e.length&&function(t,e){throw new Q(`too many indicies for array; expected ${e.length}, got ${t.length}`)}(t,e)}(r,e),r}(t,e).map(((t,n)=>new("number"==typeof t?X:tt)({dim_sel:t,dim_len:e[n],dim_chunk_len:r[n]}))),this.shape=this.dim_indexers.filter((t=>t instanceof tt)).map((t=>t.nitems))}*[Symbol.iterator](){for(const t of function*(...t){if(0===t.length)return;const e=t.map((t=>t[Symbol.iterator]())),r=e.map((t=>t.next()));if(r.some((t=>t.done)))throw new Error("Input contains an empty iterator.");for(let n=0;;){if(r[n].done){if(e[n]=t[n][Symbol.iterator](),r[n]=e[n].next(),++n>=e.length)return}else yield r.map((({value:t})=>t)),n=0;r[n]=e[n].next()}}(...this.dim_indexers)){const e=t.map((t=>t.dim_chunk_ix)),r=t.map((t=>"dim_out_sel"in t?{from:t.dim_chunk_sel,to:t.dim_out_sel}:{from:t.dim_chunk_sel,to:null}));yield{chunk_coords:e,mapping:r}}}}async function rt(t,e,r,n){let s=Y(t),a=new et({selection:e,shape:t.shape,chunk_shape:t.chunks}),i=n.prepare(new s.TypedArray(a.shape.reduce(((t,e)=>t*e),1)),a.shape,s.get_strides(a.shape)),o=r.create_queue?.()??Z();for(const{chunk_coords:e,mapping:s}of a)o.add((async()=>{let{data:a,shape:o,stride:c}=await t.getChunk(e,r.opts),u=n.prepare(a,o,c);n.set_from_chunk(i,u,s)}));return await o.onIdle(),0===a.shape.length?function(t){return"get"in t?t.get(0):t[0]}(i.data):i}function nt(t){return t.to,{from:t.to,to:t.from}}async function st(t,e,r,n,s){const a=Y(t);if("sharded"===a.kind)throw new Error("Set not supported for sharded arrays.");const i=new et({selection:e,shape:t.shape,chunk_shape:t.chunks}),o=t.chunks.reduce(((t,e)=>t*e),1),c=n.create_queue?n.create_queue():Z();for(const{chunk_coords:e,mapping:n}of i){const i=n.map((t=>t.from)),u=n.map(nt);c.add((async()=>{const n=t.resolve(a.encode_chunk_key(e)).path;let c;const d=t.chunks.slice(),h=a.get_strides(d);if(at(i,d))if(c=new a.TypedArray(o),"object"==typeof r){const t=s.prepare(c,d.slice(),h.slice());s.set_from_chunk(t,r,u)}else c.fill(r);else{c=await t.getChunk(e).then((({data:t})=>t));const n=s.prepare(c,d.slice(),h.slice());"object"==typeof r?s.set_from_chunk(n,r,u):s.set_scalar(n,i,r)}await t.store.set(n,await a.codec.encode({data:c,shape:d,stride:h}))}))}await c.onIdle()}function at(t,e){return t.every(((t,r)=>{if("number"==typeof t)return!1;const[n,s,a]=t;return s-n===e[r]&&1===a}))}function it(t,e=0,r){let n=r??t.length-e;return{length:n,subarray:(r,s=n)=>it(t,e+r,s-r),set(r,n=0){for(let s=0;s<r.length;s++)t[e+n+s]=r.get(s)},get:r=>t[e+r]}}function ot(t){return globalThis.Array.isArray(t.data)?{data:it(t.data),stride:t.stride,bytes_per_element:1}:{data:new Uint8Array(t.data.buffer,t.data.byteOffset,t.data.byteLength),stride:t.stride,bytes_per_element:t.data.BYTES_PER_ELEMENT}}const ct={prepare:(t,e,r)=>({data:t,shape:e,stride:r}),set_scalar(t,e,r){let n=ot(t);lt(n,e,function(t,e){if(globalThis.Array.isArray(t.data))return it([e]);let r=new(function(t){return"chars"in t?t.constructor.bind(null,t.chars):t.constructor}(t.data))([e]);return new Uint8Array(r.buffer,r.byteOffset,r.byteLength)}(t,r),n.bytes_per_element)},set_from_chunk(t,e,r){let n=ot(t);ft(n,ot(e),n.bytes_per_element,r)}};async function ut(t,e=null,r={}){return rt(t,e,r,ct)}async function dt(t,e,r,n={}){return st(t,e,r,n,ct)}function ht(t,e,r){return r<0&&e<t?Math.floor((t-e-1)/-r)+1:t<e?Math.floor((e-t-1)/r)+1:0}function lt(t,e,r,n){if(0===e.length)return void t.data.set(r,0);const[s,...a]=e,[i,...o]=t.stride;if("number"==typeof s)return void lt({data:t.data.subarray(i*s*n),stride:o},a,r,n);const[c,u,d]=s,h=ht(c,u,d);if(0!==a.length)for(let e=0;e<h;e++)lt({data:t.data.subarray(i*(c+d*e)*n),stride:o},a,r,n);else for(let e=0;e<h;e++)t.data.set(r,i*(c+d*e)*n)}function ft(t,e,r,n){const[s,...a]=n,[i,...o]=t.stride,[c,...u]=e.stride;if(null===s.from)return 0===a.length?void t.data.set(e.data.subarray(0,r),s.to*r):void ft({data:t.data.subarray(i*s.to*r),stride:o},e,r,a);if(null===s.to){if(0===a.length){let n=s.from*r;return void t.data.set(e.data.subarray(n,n+r),0)}return void ft(t,{data:e.data.subarray(c*s.from*r),stride:u},r,a)}const[d,h,l]=s.to,[f,y,p]=s.from,_=ht(d,h,l);if(0!==a.length)for(let n=0;n<_;n++)ft({data:t.data.subarray(i*(d+n*l)*r),stride:o},{data:e.data.subarray(c*(f+n*p)*r),stride:u},r,a);else{if(1===l&&1===p&&1===i&&1===c){let n=f*r,s=_*r;return void t.data.set(e.data.subarray(n,n+s),d*r)}for(let n=0;n<_;n++){let s=c*(f+p*n)*r;t.data.set(e.data.subarray(s,s+r),i*(d+l*n)*r)}}}async function yt(t){let e=await async function(t){let e=await t.get("/.zmetadata");if(!e)throw new n("v2 consolidated metadata",{cause:new s("/.zmetadata")});let r=u(e);return g(1===r.zarr_consolidated_format,"Unsupported consolidated format."),r}(t),r={};for(let[t,n]of Object.entries(e.metadata))r[`/${t}`]=n;return{async get(...e){let[n,s]=e;if(r[n])return c(r[n]);let a=await t.get(n,s);if(function(t){return t.endsWith(".zarray")||t.endsWith(".zgroup")||t.endsWith(".zattrs")||t.endsWith("zarr.json")}(n)&&a){let t=u(a);r[n]=t}return a},getRange:t.getRange?.bind(t),contents(){let t=[];for(let[n,s]of Object.entries(r)){let r=n.split("/"),a=r.pop(),i=r.join("/")||"/";".zarray"===a&&t.push({path:i,kind:"array"}),".zgroup"===a&&t.push({path:i,kind:"group"}),"zarr_format"in(e=s)&&3===e.zarr_format&&t.push({path:i,kind:s.node_type})}var e;return t}}}async function pt(t){return yt(t).catch((e=>(_(e,n),t)))}function _t(t,e,r,n={}){return void 0!==e&&void 0!==r&&(n={...n,headers:{...n.headers,Range:`bytes=${e}-${e+r-1}`}}),fetch(t,n)}function gt(t,e){const r="string"==typeof t?new URL(t):t;r.pathname.endsWith("/")||(r.pathname+="/");const n=new URL(e.slice(1),r);return n.search=r.search,n}async function mt(t){if(404!==t.status){if(200===t.status||206===t.status)return new Uint8Array(await t.arrayBuffer());throw new Error(`Unexpected response status ${t.status} ${t.statusText}`)}}const bt=class{url;#y;#p;constructor(t,e={}){this.url=t,this.#y=e.overrides??{},this.#p=e.useSuffixRequest??!1}#_(t){return e=this.#y,r=t,{...e,...r,headers:{...e.headers,...r.headers}};var e,r}async get(t,e={}){let r=gt(this.url,t).href;return mt(await fetch(r,this.#_(e)))}async getRange(t,e,r={}){let n,s=gt(this.url,t),a=this.#_(r);return n="suffixLength"in e?await async function(t,e,r,n){if(n)return fetch(t,{...r,headers:{...r.headers,Range:`bytes=-${e}`}});let s=await fetch(t,{...r,method:"HEAD"});if(!s.ok)return s;let a=s.headers.get("Content-Length"),i=Number(a);return _t(t,i-e,i,r)}(s,e.suffixLength,a,this.#p):await _t(s,e.offset,e.length,a),mt(n)}}}}]);